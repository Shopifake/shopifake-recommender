"""Business logic that powers the chat endpoint."""

from __future__ import annotations

import logging

from src.models.chat import ChatRequest, ChatResultPayload
from src.services.chat.clarifications import generate_more_info_reply
from src.services.chat.history_utils import needs_more_info
from src.services.chat.rag_pipeline import (
    rewrite_as_rag_query,
    search_recommendations_with_rag_query,
)
from src.services.chat.reply_builder import generate_reply
from src.services.chat.result_store import ChatResultStore
from src.services.clients.decoder_client import DecoderClient
from src.services.clients.encoder_client import EncoderClient
from src.services.queue.embedding_queue import get_redis_client
from src.services.storage.qdrant_service import QdrantService, create_qdrant_service

logger = logging.getLogger(__name__)


class ChatOrchestrator:
    """Coordinates embeddings, vector search, and decoder generation."""

    def __init__(
        self,
        *,
        encoder: EncoderClient | None,
        decoder: DecoderClient | None,
        qdrant_service: QdrantService,
        result_store: ChatResultStore,
    ) -> None:
        self._encoder = encoder
        self._decoder = decoder
        self._qdrant_service = qdrant_service
        self._result_store = result_store

    async def initialize_request(self, request_id: str) -> None:
        await self._result_store.initialize(request_id)

    async def process_request(self, request_id: str, payload: ChatRequest) -> None:
        try:
            result = await self._execute(payload)
            await self._result_store.save_success(request_id, result)
        except Exception as exc:  # pylint: disable=broad-exception-caught
            logger.exception("Chat job %s failed", request_id)
            await self._result_store.save_failure(request_id, str(exc))

    async def _execute(self, payload: ChatRequest) -> ChatResultPayload:
        print(f"[ChatOrchestrator] Received chat request: {payload}")
        query = payload.query.strip()
        if not query:
            print("[ChatOrchestrator] Query text is empty, raising error.")
            raise ValueError("Query text cannot be empty")

        # Only ask for more info if there is no RAG entry in history
        if needs_more_info(payload):
            has_rag_entry = any(
                getattr(entry, "role", None) == "rag" for entry in payload.history
            )
            if not has_rag_entry:
                print("[ChatOrchestrator] Needs more info from user.")
                reply = await generate_more_info_reply(self._decoder, payload)
                result = ChatResultPayload(
                    reply=reply,
                    decoder_satisfaction="need_more_info",
                    recommendations=[],
                )
                print(f"[ChatOrchestrator] Returning: {result}")
                return result

        print("[ChatOrchestrator] Rewriting chat history and query for RAG search...")
        rag_query = await rewrite_as_rag_query(payload, self._decoder)
        print(f"[ChatOrchestrator] RAG query generated by decoder: '{rag_query}'")
        recommendations = await search_recommendations_with_rag_query(
            payload,
            rag_query,
            self._encoder,
            self._qdrant_service,
        )
        print(f"[ChatOrchestrator] Recommendations found: {recommendations}")
        status = "satisfied" if recommendations else "unsatisfied"
        print(f"[ChatOrchestrator] Decoder satisfaction status: {status}")
        if status == "satisfied":
            reply_result = await generate_reply(self._decoder, payload, recommendations)
            if isinstance(reply_result, tuple):
                reply, recommendations = reply_result
            else:
                reply = reply_result
            print(f"[ChatOrchestrator] Reply generated: '{reply}'")
        else:
            reply = (
                "Sorry, I couldn't find any suitable products. Could you provide "
                "more details?"
            )
            print(f"[ChatOrchestrator] Unsatisfied reply: '{reply}'")
            recommendations = []

        print(
            "[ChatOrchestrator] Final result payload: "
            f"reply='{reply}', status='{status}', recommendations={recommendations}"
        )
        return ChatResultPayload(
            reply=reply,
            decoder_satisfaction=status,
            recommendations=recommendations,
        )


def create_chat_orchestrator(
    *,
    encoder: EncoderClient | None,
    decoder: DecoderClient | None,
    result_store: ChatResultStore | None = None,
) -> ChatOrchestrator:
    store = result_store
    if store is None:
        client = get_redis_client()
        store = ChatResultStore(client)
    qdrant = create_qdrant_service()
    return ChatOrchestrator(
        encoder=encoder,
        decoder=decoder,
        qdrant_service=qdrant,
        result_store=store,
    )
